{"filter":false,"title":"Immediate","tooltip":"Immediate","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":179,"column":20},"end":{"row":180,"column":0},"action":"insert","lines":["",""]},{"start":{"row":180,"column":0},"end":{"row":181,"column":0},"action":"insert","lines":["",""]}]}]]},"immediate":{"folds":[],"scrolltop":59,"scrollleft":0,"selection":{"start":{"row":181,"column":0},"end":{"row":181,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":3,"state":"start","mode":"ace/mode/javascript"},"type":"jsbrowser","history":["var c = new Class();","var Class = Object.class({extends: Object, _construct: function() {this.test = \"Yay!!!\"}});","var c = new Class();","var Class = Object.class({_construct: function() {this.test = \"Yay!!!\"}});","(function(root, factory) {\n    if(typeof(define) === 'function' && define.amd) {\n        define(function() {\n            // expose plugin globally\n            return (root.Object.class = factory);\n        });\n    } else if (typeof exports !== 'undefined') {\n        exports = factory();\n    } else if(typeof(root) === 'object' && typeof(root.document) === 'object') {\n        root.Object.class = factory;\n    }\n})(window, function() {\n\n    /**\n     * Class\n     * Creates a class by passing in a class definition as a javascript object\n     * @param {Object} definition the class definition object\n     * @return {function} the newly created class\n     */\n    var Class = function(definition) {\n        // load class helper functions\n        // define simple constructor\n        var classDefinition = function() {};\n        classDefinition.prototype._construct = classDefinition;\n    \n        if (definition) {\n    \n            // set construnctor if it exists in definition\n            if (definition._construct) {\n                classDefinition.prototype._construct = \n                    classDefinition = \n                        definition._construct;\n            }\n    \n            // extend a class if it's set in the definition\n            if (definition.extends) {\n                Class._inherits(classDefinition, definition.extends);\n    \n            }\n    \n            // implement a object of method and properties\n            if (definition.implements) {\n                if (definition.implements instanceof Array) {\n                    var i;\n                    for (i = 0; i < definition.implements.length; i++) {\n                        Class._extendPrototypeOf(classDefinition, definition.implements[i]);\n                    }\n                } else if (typeof definition.imlements === 'object') {\n                    Class._extendPrototypeOf(classDefinition, definition.implements);\n                } else {\n                    throw new Error(\"error implementing object methods\");\n                }\n            }\n    \n            // set the prototype object of the class\n            if (definition.prototype) {\n                Class._extendPrototypeOf(classDefinition, definition.prototype);\n            }\n    \n            if (definition.static) {\n                for (i in definition.static) {\n                    classDefinition[i] = definition.static[i];\n                }\n            }\n        }\n    \n        /**\n         * Provides easy access to the current class' static methods\n         * \n         * @return {function} the class' constructor\n         */\n        classDefinition.prototype._self = function() {\n            return classDefinition;\n        };\n    \n        if(definition.extends) {\n            // variable to use in the closure\n            var superClass = definition.extends;\n            \n            /**\n             * Provides easy access to the parent class' prototype\n             * \n             * @static\n             * @return {mixed} result of the execution if there is any\n             */\n            classDefinition._super = function(context, method, argv) {\n                var result;\n                \n                if(!context) {\n                    throw new Error('Undefined context.');\n                }\n                \n                var _this = context;\n                \n                if(!argv) {\n                    argv = [];\n                }\n                \n                if(method) {\n                    if(method instanceof Array) {\n                        argv = method;\n                        method = undefined;\n                    } else if(typeof(method) !== 'string') {\n                        throw new Error('Expected string for method value, but ' + typeof(method) + ' given.');\n                    }\n                }\n                \n                if (method) {\n                    // execute a method from the parent prototype\n                    if(superClass.prototype[method] &&\n                            typeof(superClass.prototype[method]) === 'function') {\n                        result = superClass.prototype[method].apply(_this, argv);\n                    } else {\n                        throw new Error(\"Parent class does not have a method named '\" + method + \"'.\");\n                    }\n                } else {\n                    // if no method is set, then we execute the parent constructor\n                    result = superClass.apply(_this, argv);\n                }\n    \n                return result;\n            };\n        }\n    \n        // return the new class\n        return classDefinition;\n    };\n    \n    /**\n     * <p>Creates a new class and inherits a parent class</p>\n     * <p><b>Note: when calling a super function use: [ParentClass].prototype.[method].call(this, arguments)</b></p>\n     * \n     * @param {object} childClass the class that will inherit the parent class\n     * @param {object} baseClass the class that this class will inherit\n     * @private\n     * @static\n     */\n    Class._inherits = function(childClass, baseClass) {\n        // inherit parent's methods\n        var std_class = function() {\n        };\n        std_class.prototype = baseClass.prototype;\n        childClass.prototype = new std_class();\n        // set the constructor\n        childClass.prototype._construct = \n            childClass.prototype.constructor = \n                childClass;\n        // return the new class\n        return childClass;\n    };\n    \n    /**\n     * Copies methods from an object to the class prototype\n     * \n     * @param {object} childClass the class that will inherit the methods\n     * @param {object} methods the object that contains the methods\n     * @private\n     * @static\n     */\n    Class._extendPrototypeOf = function(childClass, methods) {\n        for (var i in methods) {\n            childClass.prototype[i] = methods[i];\n        }\n    \n        return childClass;\n    };\n    \n    return Class;\n\n});"],"pos":-1},"timestamp":1422873779823,"hash":"f7b579528c9bed71b2ebbb55a490e9820ed5ebb2"}